From 19b4b4bcfacc3d8d5ae944290efc9687fe600365 Mon Sep 17 00:00:00 2001
From: Jozef Mlich <jmlich83@gmail.com>
Date: Sun, 9 Jul 2023 09:02:51 +0000
Subject: [PATCH] Fix build with Qt6

---
 src/nemo-dbus/dbus.cpp                  |  4 ++++
 src/plugin/declarativedbusadaptor.cpp   |  4 ++++
 src/plugin/declarativedbusinterface.cpp | 16 ++++++++++++++++
 3 files changed, 24 insertions(+)

diff --git a/src/nemo-dbus/dbus.cpp b/src/nemo-dbus/dbus.cpp
index a765d41..cacb95f 100644
--- a/src/nemo-dbus/dbus.cpp
+++ b/src/nemo-dbus/dbus.cpp
@@ -101,7 +101,11 @@ QVariant demarshallDBusArgument(const QVariant &val, int depth)
         for (int i = 0; i < arr.size(); ++i)
             lst << QVariant::fromValue(static_cast<quint8>(arr[i]));
         res = QVariant::fromValue(lst);
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+    } else if (type == val.typeId()) {
+#else
     } else if (type == val.type()) {
+#endif
         /* Already is built-in qt type, use as is */
         res = val;
     } else if (type == qMetaTypeId<QDBusVariant>()) {
diff --git a/src/plugin/declarativedbusadaptor.cpp b/src/plugin/declarativedbusadaptor.cpp
index 84ca506..45eef2b 100644
--- a/src/plugin/declarativedbusadaptor.cpp
+++ b/src/plugin/declarativedbusadaptor.cpp
@@ -242,7 +242,11 @@ QString DeclarativeDBusAdaptor::introspect(const QString &) const
 
 QDBusArgument &operator << (QDBusArgument &argument, const QVariant &value)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+    switch (value.typeId()) {
+#else
     switch (value.type()) {
+#endif
     case QVariant::String:
         return argument << value.toString();
     case QVariant::StringList:
diff --git a/src/plugin/declarativedbusinterface.cpp b/src/plugin/declarativedbusinterface.cpp
index 9659128..8ed81f9 100644
--- a/src/plugin/declarativedbusinterface.cpp
+++ b/src/plugin/declarativedbusinterface.cpp
@@ -470,10 +470,18 @@ static void flattenVariantArrayGuessType(QVariant &var)
     /* If all items in the list do not share the same type:
      * use as is -> each value will be wrapped in variant
      * container */
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+    int t = arr[0].typeId();
+#else
     int t = arr[0].type();
+#endif
     int n = arr.size();
     for (int i = 1; i < n; ++i) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+        if (arr[i].typeId() != t)
+#else
         if (arr[i].type() != t)
+#endif
             return;
     }
 
@@ -494,7 +502,11 @@ static void flattenVariantArrayGuessType(QVariant &var)
         /* Unhandled types are encoded as variant:array:variant:val
          * instead of variant:array:val what we actually want.
          */
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+        qWarning("unhandled array type: %d (%s)", t, QMetaType(t).name());
+#else
         qWarning("unhandled array type: %d (%s)", t, QVariant::typeToName(t));
+#endif
         break;
     }
 }
@@ -870,7 +882,11 @@ void DeclarativeDBusInterface::signalHandler(const QDBusMessage &message)
 
     for (int i = 0; i < normalized.count(); ++i) {
         const QVariant &arg = normalized.at(i);
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
+        args[i] = QGenericArgument(QMetaType(arg.metaType()).name(), arg.data());
+#else
         args[i] = Q_ARG(QVariant, arg);
+#endif
     }
 
     QMetaMethod method = m_signals.value(message.member());
-- 
2.40.1

