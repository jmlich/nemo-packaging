diff --git a/.gitignore b/.gitignore
index 2e0d0b25..a81436a3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,4 +2,4 @@ build-armel/*
 build-i386/*
 configure-stamp
 build-stamp
-
+.qmake.stash
\ No newline at end of file
diff --git a/configure b/configure
index 4ebf56c6..3522d166 100755
--- a/configure
+++ b/configure
@@ -540,7 +540,12 @@ if [ -z "$QTDIR" ]; then
         if [ $? -eq 0 ]; then
             QMAKE_BIN=`which qmake-qt5`
         else
-            echo "qmake was not found in your path\n"
+            which qmake6 > /dev/null
+            if [ $? -eq 0 ]; then
+                QMAKE_BIN=`which qmake6`
+            else
+                echo "qmake was not found in your path\n"
+            fi
         fi
     fi
 elif [ -f "$QTDIR/bin/qmake" ]; then
diff --git a/src/mcalendar.cpp b/src/mcalendar.cpp
index 17104958..c21badb8 100644
--- a/src/mcalendar.cpp
+++ b/src/mcalendar.cpp
@@ -269,7 +269,11 @@ void MCalendar::setDate(int year, int month, int day)
 //! Sets the calendar date from QDate
 void MCalendar::setDate(const QDate &date)
 {
+#if QT_VERSION < 0x051500
     QDateTime datetime(date);
+#else
+    QDateTime datetime(date.startOfDay());
+#endif
     setDateTime(datetime);
 }
 
diff --git a/src/mdebug.h b/src/mdebug.h
index 6a715acb..3d60f870 100644
--- a/src/mdebug.h
+++ b/src/mdebug.h
@@ -65,7 +65,11 @@ private:
     QtMsgType convertMsgType(int type);
 
     struct Stream {
+#if QT_VERSION < 0x051500
         Stream(int type) : ts(&buffer, QIODevice::WriteOnly), ref(1), type(type), output(true) {}
+#else
+        Stream(int type) : ts(&buffer, QIODeviceBase::WriteOnly), ref(1), type(type), output(true) {}
+#endif
 
         QTextStream ts;
         QString buffer;
diff --git a/src/micuconversions.cpp b/src/micuconversions.cpp
index 8bb09601..9d4c85cf 100644
--- a/src/micuconversions.cpp
+++ b/src/micuconversions.cpp
@@ -22,6 +22,10 @@
 #include <QDebug>
 #include <QString>
 
+#if QT_VERSION >= 0x051500
+    #include <QRegularExpression>
+#endif
+
 #include <unicode/unistr.h>
 #include <unicode/datefmt.h>
 
@@ -326,10 +330,19 @@ QString MIcuConversions::icuDatePatternEscaped(const QString &str)
 QString MIcuConversions::parseOption(const QString &localeName, const QString &option)
 {
     QString value;
+#if QT_VERSION < 0x051500
     QRegExp regexp("^[^@]+@.*"+QRegExp::escape(option)+"=([^@=;]+)($|;.*$)");
     if(regexp.indexIn(localeName) >= 0 && regexp.capturedTexts().size() == 3) {
         value = regexp.capturedTexts().at(1);
     }
+#else
+    QRegularExpression regexp("^[^@]+@.*"+QRegularExpression::escape(option)+"=([^@=;]+)($|;.*$)");
+    QRegularExpressionMatch match = regexp.match(localeName);
+
+    if (match.hasMatch() && match.capturedTexts().size() == 3) {
+        value = match.captured(1);
+    }
+#endif
     return value;
 }
 
@@ -339,7 +352,11 @@ QString MIcuConversions::setOption(const QString &localeName, const QString &opt
     if(!newLocaleName.isEmpty() && !option.isEmpty()) {
         if(value.isEmpty()) { // remove option completely
             if(newLocaleName.contains('@') && newLocaleName.contains(option)) {
+#if QT_VERSION < 0x051500
                 QRegExp regexp("^([^@]+@.*)"+QRegExp::escape(option)+"=[^@=;]+($|;.*$)");
+#else
+                QRegularExpression regexp("^([^@]+@.*)"+QRegularExpression::escape(option)+"=[^@=;]+($|;.*$)");
+#endif
                 newLocaleName.replace(regexp, "\\1\\2");
                 newLocaleName.replace(QLatin1String(";;"), QLatin1String(";"));
                 newLocaleName.replace(QLatin1String("@;"), QLatin1String("@"));
@@ -360,7 +377,11 @@ QString MIcuConversions::setOption(const QString &localeName, const QString &opt
                     newLocaleName += ';' + option + '=' + value;
             }
             else {
+#if QT_VERSION < 0x051500
                 QRegExp regexp("^([^@]+@.*"+QRegExp::escape(option)+"=)[^@=;]+($|;.*$)");
+#else
+                QRegularExpression regexp("^([^@]+@.*"+QRegularExpression::escape(option)+"=)[^@=;]+($|;.*$)");
+#endif
                 newLocaleName.replace(regexp, "\\1"+value+"\\2");
             }
         }
diff --git a/src/mlocale.cpp b/src/mlocale.cpp
index 8cbb0165..cd7d6587 100644
--- a/src/mlocale.cpp
+++ b/src/mlocale.cpp
@@ -48,6 +48,10 @@ using namespace icu;
 #include <QDateTime>
 #include <QPointer>
 
+#if QT_VERSION >= 0x051500
+    #include <QRegularExpression>
+#endif
+
 #ifdef HAVE_ICU
 #include "mcollator.h"
 #include "mcalendar.h"
@@ -286,7 +290,8 @@ bool MTranslationCatalog::loadWith(MLocale *mlocale, MLocale::Category category)
     // load "foo_de.qm" because the language has been switched to German
     // but "foo_de.qm" does not exist. We do *not* want to keep the previous
     // "foo_ar.qm" contents in that case.
-    _translator.load("", 0);
+    bool _ = _translator.load("", 0);
+    Q_UNUSED(_)
     return false;
 }
 
@@ -698,7 +703,13 @@ void MLocalePrivate::simplifyDateFormatForMixing(icu::DateFormat *df) const
         // hardcoded text in the language of the the time category and
         // most likely not understandable in the language of the
         // message locale:
-        icuFormatQString.replace(QRegExp("'[^']*'"), QLatin1String(""));
+        icuFormatQString.replace(
+#if QT_VERSION < 0x051500
+            QRegExp("'[^']*'"),
+#else
+            QRegularExpression("'[^']*'"),
+#endif
+            QLatin1String(""));
         // use stand-alone versions of month names and weekday names only
         // inflected versions will make no sense in the context of a different
         // language:
@@ -875,10 +886,22 @@ bool MLocalePrivate::mixingSymbolsWanted(const QString &categoryNameMessages, co
                       || categoryScriptTime == QLatin1String("Hebr"));
     bool messagesIsRtl = (categoryScriptMessages == QLatin1String("Arab")
                           || categoryScriptMessages == QLatin1String("Hebr"));
-    if (categoryNameTime.contains(QRegExp("@.*mix-time-and-language=yes"))) {
+    if (categoryNameTime.contains(
+#if QT_VERSION < 0x051500
+        QRegExp("@.*mix-time-and-language=yes")
+#else
+        QRegularExpression("@.*mix-time-and-language=yes")
+#endif
+    )) {
         return true;
     }
-    else if(!categoryNameTime.contains(QRegExp("@.*mix-time-and-language=no"))
+    else if(!categoryNameTime.contains(
+#if QT_VERSION < 0x051500
+        QRegExp("@.*mix-time-and-language=no")
+#else
+        QRegularExpression("@.*mix-time-and-language=no")
+#endif
+    )
        && languageMessages != languageTime
        && languageMessages != "zh"
        && languageMessages != "ja"
@@ -1651,6 +1674,7 @@ bool MLocalePrivate::parseIcuLocaleString(const QString &localeString, QString *
     // as in the above example, but there is the exception
     // es_419, i.e. Spanish in Latin America where the “country code”
     // is “419”.
+#if QT_VERSION < 0x051500
     QRegExp regexp("^([a-z]{2,3})(?:_([A-Z][a-z]{3,3}))?(?:_([A-Z]{2,2}|419))?(?:_{1,2}([A-Z][A-Z_]*))?(?:@.*)?$");
     if (regexp.indexIn(localeString) == 0
         && regexp.capturedTexts().size() == 5) {
@@ -1660,6 +1684,18 @@ bool MLocalePrivate::parseIcuLocaleString(const QString &localeString, QString *
         *variant  = regexp.capturedTexts().at(4); // "" if no match
         return true;
     }
+#else
+    QRegularExpression regexp("^([a-z]{2,3})(?:_([A-Z][a-z]{3,3}))?(?:_([A-Z]{2,2}|419))?(?:_{1,2}([A-Z][A-Z_]*))?(?:@.*)?$");
+    QRegularExpressionMatch match = regexp.match(localeString);
+
+    if (match.hasMatch() && match.capturedTexts().size() == 5) {
+        *language = match.captured(1);
+        *script = match.captured(2);
+        *country = match.captured(3);
+        *variant = match.captured(4);
+        return true;
+    }
+#endif
     else {
         *language = "";
         *script = "";
@@ -1747,8 +1783,8 @@ cleanLanguageCountryPosix(QString &localeString)
     // let’s make this behave the same way as the icu locale names work for es_419,
     // we only use LANG as a fallback to specify a locale when gconf isn’t available
     // or doesn’t work.
+#if QT_VERSION < 0x051500
     QRegExp regexp("([a-z]{2,3})(_([A-Z]{2,2}|419))?(?:.(?:[a-zA-Z0-9-]+))?(@([A-Z][a-z]+))?");
-
     if (regexp.indexIn(localeString) == 0 &&
             regexp.capturedTexts().size() == 6) { // size of regexp pattern above
         QStringList strings;
@@ -1764,7 +1800,30 @@ cleanLanguageCountryPosix(QString &localeString)
 
         // we don't need variant
         return strings.join("_");
-    } else {
+    }
+#else
+    QRegularExpression regexp("([a-z]{2,3})(_([A-Z]{2,2}|419))?(?:.(?:[a-zA-Z0-9-]+))?(@([A-Z][a-z]+))?");
+    QRegularExpressionMatch match = regexp.match(localeString);
+
+    if (match.hasMatch()
+            && match.capturedTexts().size() == 6) { // size of regexp pattern above
+        QStringList strings;
+        strings << match.captured(1); // language
+
+        // POSIX locale modifier, interpreted as script
+        if (!match.captured(5).isEmpty()) {
+            strings << match.captured(5);
+        }
+
+        if (!match.captured(3).isEmpty()) {
+            strings << match.captured(3); // country
+        }
+
+        // we don't need variant
+        return strings.join("_");
+    }
+#endif
+    else {
         //Malformed locale code
         return QString(PosixStr);
     }
@@ -2817,7 +2876,13 @@ void MLocalePrivate::fixFormattedNumberForRTL(QString *formattedNumber) const
         // (actually some of the Arabic currency symbols have RLM markers in the icu
         // data ...).
         removeDirectionalFormattingCodes(formattedNumber);
-        if(formattedNumber->contains(QRegExp(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]")))) {
+        if (formattedNumber->contains(
+#if QT_VERSION < 0x051500
+            QRegExp(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]"))
+#else
+            QRegularExpression(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]"))
+#endif
+        )) {
             swapPostAndPrefixOfFormattedNumber(formattedNumber);
         }
     }
@@ -2864,6 +2929,7 @@ void MLocalePrivate::fixFormattedNumberForRTL(QString *formattedNumber) const
     formattedNumber->prepend(QChar(0x202A)); // LEFT-TO-RIGHT EMBEDDING
     formattedNumber->append(QChar(0x202C)); // POP DIRECTIONAL FORMATTING
 #endif
+    Q_UNUSED(q)
     return;
 }
 #endif
@@ -2872,7 +2938,13 @@ void MLocalePrivate::fixFormattedNumberForRTL(QString *formattedNumber) const
 void MLocalePrivate::fixParseInputForRTL(QString *formattedNumber) const
 {
     removeDirectionalFormattingCodes(formattedNumber);
-    if(formattedNumber->contains(QRegExp(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]")))) {
+    if(formattedNumber->contains(
+#if QT_VERSION < 0x051500
+        QRegExp(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]")))
+#else
+        QRegularExpression(QString::fromUtf8("[٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹]")))
+#endif
+    ) {
         swapPostAndPrefixOfFormattedNumber(formattedNumber);
     }
 }
@@ -3846,13 +3918,22 @@ QStringList MLocale::exemplarCharactersIndex() const
     // the current locale:
     QStringList exemplarCharactersIndex
         = QString::fromUtf8("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z")
-        .split(QLatin1String(" "),QString::SkipEmptyParts);
+#if QT_VERSION < 0x051500
+            .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+            .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
     QString charStr;
     if (collationLocaleName.contains(QLatin1String("collation=unihan"))) {
         charStr = QString::fromUtf8("⼀ ⼁ ⼂ ⼃ ⼄ ⼅ ⼆ ⼇ ⼈ ⼉ ⼊ ⼋ ⼌ ⼍ ⼎ ⼏ ⼐ ⼑ ⼒ ⼓ ⼔ ⼕ ⼖ ⼗ ⼘ ⼙ ⼚ ⼛ ⼜ ⼝ ⼞ ⼟ ⼠ ⼡ ⼢ ⼣ ⼤ ⼥ ⼦ ⼧ ⼨ ⼩ ⼪ ⼫ ⼬ ⼭ ⼮ ⼯ ⼰ ⼱ ⼲ ⼳ ⼴ ⼵ ⼶ ⼷ ⼸ ⼹ ⼺ ⼻ ⼼ ⼽ ⼾ ⼿ ⽀ ⽁ ⽂ ⽃ ⽄ ⽅ ⽆ ⽇ ⽈ ⽉ ⽊ ⽋ ⽌ ⽍ ⽎ ⽏ ⽐ ⽑ ⽒ ⽓ ⽔ ⽕ ⽖ ⽗ ⽘ ⽙ ⽚ ⽛ ⽜ ⽝ ⽞ ⽟ ⽠ ⽡ ⽢ ⽣ ⽤ ⽥ ⽦ ⽧ ⽨ ⽩ ⽪ ⽫ ⽬ ⽭ ⽮ ⽯ ⽰ ⽱ ⽲ ⽳ ⽴ ⽵ ⽶ ⽷ ⽸ ⽹ ⽺ ⽻ ⽼ ⽽ ⽾ ⽿ ⾀ ⾁ ⾂ ⾃ ⾄ ⾅ ⾆ ⾇ ⾈ ⾉ ⾊ ⾋ ⾌ ⾍ ⾎ ⾏ ⾐ ⾑ ⾒ ⾓ ⾔ ⾕ ⾖ ⾗ ⾘ ⾙ ⾚ ⾛ ⾜ ⾝ ⾞ ⾟ ⾠ ⾡ ⾢ ⾣ ⾤ ⾥ ⾦ ⾧ ⾨ ⾩ ⾪ ⾫ ⾬ ⾭ ⾮ ⾯ ⾰ ⾱ ⾲ ⾳ ⾴ ⾵ ⾶ ⾷ ⾸ ⾹ ⾺ ⾻ ⾼ ⾽ ⾾ ⾿ ⿀ ⿁ ⿂ ⿃ ⿄ ⿅ ⿆ ⿇ ⿈ ⿉ ⿊ ⿋ ⿌ ⿍ ⿎ ⿏ ⿐ ⿑ ⿒ ⿓ ⿔ ⿕");
         // add a dummy bucket at the end 𪛖 is the last character in unihan order:
         charStr += QString::fromUtf8(" 𪛖");
-        return charStr.split(QLatin1String(" "),QString::SkipEmptyParts);
+        return charStr
+#if QT_VERSION < 0x051500
+            .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+            .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
     }
     // special treatment for Chinese locales because these have the
     // collation options "stroke" and "pinyin" which require different
@@ -3864,13 +3945,23 @@ QStringList MLocale::exemplarCharactersIndex() const
     if(collationLocaleName.startsWith(QLatin1String("zh"))) {
         if(collationLocaleName.contains(QLatin1String("collation=zhuyin"))) {
             charStr = QString::fromUtf8("ㄅ ㄆ ㄇ ㄈ ㄉ ㄊ ㄋ ㄌ ㄍ ㄎ ㄏ ㄐ ㄑ ㄒ ㄓ ㄔ ㄕ ㄖ ㄗ ㄘ ㄙ ㄧ ㄨ ㄩ ㄚ ㄛ ㄜ ㄝ ㄞ ㄟ ㄠ ㄡ ㄢ ㄣ ㄤ ㄥ ㄦ ㄪ ㄫ ㄬ ㄭ");
-            return charStr.split(QLatin1String(" "),QString::SkipEmptyParts);
+            return charStr
+#if QT_VERSION < 0x051500
+                .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+                .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
         }
         if(collationLocaleName.contains(QLatin1String("collation=pinyinsearch"))) {
             collationLocaleName = QLatin1String("zh_CN@collation=pinyinsearch");
             charStr = QString::fromUtf8("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
             exemplarCharactersIndex =
-                charStr.split(QLatin1String(" "),QString::SkipEmptyParts);
+                charStr
+#if QT_VERSION < 0x051500
+                    .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+                    .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
             // to get all characters with pinyin starting with z
             // (last one is 蓙) into the Z bucket
             exemplarCharactersIndex << QString::fromUtf8("Α"); // GREEK CAPITAL LETTER ALPHA
@@ -3912,8 +4003,12 @@ QStringList MLocale::exemplarCharactersIndex() const
     charStr.remove(']');
     charStr.remove('{');
     charStr.remove('}');
-    exemplarCharactersIndex = charStr.split(QLatin1String(" "),
-                                            QString::SkipEmptyParts);
+    exemplarCharactersIndex = charStr
+#if QT_VERSION < 0x051500
+        .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+        .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
 
     // Special hack for the last Japanese bucket:
     if (exemplarCharactersIndex.last() == QString::fromUtf8("わ")) {
@@ -3930,7 +4025,12 @@ QStringList MLocale::exemplarCharactersIndex() const
          || collationLocaleName.startsWith(QLatin1String("zh_SG")))
         ) {
         charStr = QString::fromUtf8("ａ ｂ ｃ ｄ ｅ ｆ ｇ ｈ ｉ ｊ ｋ ｌ ｍ ｎ ｏ ｐ ｑ ｒ ｓ ｔ ｕ ｖ ｗ ｘ ｙ ｚ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
-        return charStr.split(QLatin1String(" "),QString::SkipEmptyParts);
+        return charStr
+#if QT_VERSION < 0x051500
+                .split(QLatin1String(" "),QString::SkipEmptyParts);
+#else
+                .split(QLatin1String(" "),Qt::SkipEmptyParts);
+#endif
     }
     return exemplarCharactersIndex;
 }
@@ -4770,8 +4870,14 @@ QString MLocalePrivate::formatPhoneNumber( const QString& phoneNumber,
     MLocale::PhoneNumberGrouping grouping ) const
 {
   // first do sanity check of the input string
+#if QT_VERSION < 0x051500
   QRegExp rx( "\\+?\\d*" );
   if ( ! rx.exactMatch( phoneNumber ) )
+#else
+  QRegularExpression rx( QRegularExpression::anchoredPattern("\\+?\\d*") );
+  QRegularExpressionMatch match = rx.match(phoneNumber);
+  if (!match.hasMatch())
+#endif
   {
     qWarning( "MLocale::formatPhoneNumber: cannot understand number: %s",
 	      qPrintable( phoneNumber ) );
diff --git a/src/mlocale.h b/src/mlocale.h
index ca6344de..68e322e8 100644
--- a/src/mlocale.h
+++ b/src/mlocale.h
@@ -28,7 +28,9 @@
 #include <QMap>
 
 class QString;
-class QStringList;
+#if QT_VERSION < 0x051500
+    class QStringList;
+#endif
 class QDateTime;
 class QTranslator;
 
diff --git a/src/mlocationdatabase.cpp b/src/mlocationdatabase.cpp
index 4b21c14b..774e86ba 100644
--- a/src/mlocationdatabase.cpp
+++ b/src/mlocationdatabase.cpp
@@ -229,8 +229,13 @@ bool MLocationDatabasePrivate::loadTimeZoneData()
     QString line;
     do {
         line = stream.readLine();
+#if QT_VERSION < 0x051500
         QStringList timeZoneIds(line.split(QLatin1Char(' '),
                                            QString::SkipEmptyParts));
+#else
+        QStringList timeZoneIds(line.split(QLatin1Char(' '),
+                                           Qt::SkipEmptyParts));
+#endif
         if(!timeZoneIds.isEmpty()) {
             QString canonicalTimeZoneId = timeZoneIds.first();
             foreach(const QString &alias, timeZoneIds) {
